# Voting smart contract 

Try running some of the following tasks:

```shell
npx hardhat test # runs tests
npx hardhat coverage # shows code coverage 
npx hardhat check # runs sol linter
npx hardhat node
node scripts/sample-script.js
npx hardhat help
```

## Вопросы по ТЗ

ТЗ (на мой взгляд) неполное и требует уточнений без которых написание кода в реальной жизни просто бессмысленно, собственно ниже вопросы которые в реальном процессе были бы заданы заказчику (напрямую или через менеджера)

- В ТЗ упоминаются роли owner и admin, в одном месте указано что только admin может создавать голосование, в другом описан сценарий когда голосование создает owner. То есть этот момент с заказчиком нужно проговаривать. Код написан из предположения что owner и admin - это все таки разные роли, но это предположение, не более
- В ТЗ неявно предполагается что победитель будет один, а это не так. Ситуация когда победителей несколько не описана, непонятно что в этом случае делать - арбитраж, победители делят приз поровну, какие то ручные манипуляции со стороны admin? Код написан из предположения что победители делят приз поровну.
- Есть ли ограничение на число участников в голосовании? В коде использован uint32, исходя из того что 4 миллиарда претендентов удовлетворяет нужды, это норм с точки зрения реальной жизни но все же заказчику это стоит озвучить.
- Есть ли ограничения на число голосов? В коде опять же использован uint32, что IRL может быть норм, но строго говоря теоретически возможно переполнение.
- Возможно ли что в будущем стоимость голосования поменяется? Код написан из предположения что нет и значения заданы явно, но если да - то стоимость пойдет в параметр старта голосования и поменяется структура как самого голосования так и логика завершения голования. Существенно усложниться логика учета голоса и *возможно* будет иметь смысл рассматривать деплой контракта под каждое голосование.
- Какие требования к участникам голосования (адресам) - будут ли это обычные адреса или адреса смарт контрактов? Код написан из предположения что это обычные адреса, если предполагается участие смарт-контрактов - нужно менять логику вывода приза и прорабатывать логику отказа при трасфере средств. (тот же самый вопрос к адресу owner-а - предполагается ли создание контракта из других контрактов? и соотв. вывод fee на обычный кошелек или на смартконтракт)
- Ничего не сказано о fee еще не завершенных голований - его можно выводить или нет? Код написан из предположения что выводить можно fee только завершенных голований.
- Продолжительность голосования озвучена в три дня - в блокчейне нет средств точного контроля времени. Во первых это необходимо обьяснить заказчику во вторых рассказать что есть два источника по которым можно попытаться определить время - timestamp блока (разброс в 900 секунд, то есть 15 часов) или же по число блоков помноженных на среднее время между блоками - тут плавает и нужно брать статистику и сразу закладывать механизм уточнения в контракте.
- В ТЗ есть требование по доступности данных голования но ничего не сказано в какой момент. После завершения голосования - нужны ли эти данные? Нужны ли ВСЕ данные? например за счет удаления информации о voters можно было бы снизить расход газа на других транзакциях (к примеру при старте голосования)
- из ТЗ напрямую не следует но я бы задал этот вопрос - в случае изменений логики (или наденных багов) - насколько DAPP привязан к адресу контракта? То есть надо ли размещать сам контракт интерфейсом в мир или же нужен контракт прокладка через который идут запросы к контракту голосования и на котором если что можно всегда поменять адрес контракта голосования (то есть Proxy Upgrade Pattern)
- в ТЗ четко сказано что выбор победителя и выплата награды должна быть в одной функции (тразакции) и тут не поспоришь, но я бы обратил внимание заказчика на то что в случае если победителей несколько - может возникнуть ситуация когда ни одному из них не будет выгодно забирать выигрыш. Возможно имеет смысл разнести выбор победителя(ей) в одну функцию и вывод средств победителем - в другую. (все эти рассуждения справедливы только в сценарии когда возможно что поюедителей несколько, если есть механизм выбора единственного победителя - этот пункт не актуален)
- Переживаем ли мы по поводу переполнений (как на uint32 так и на uint256) - стоимость такого переполнения IRL конкретно на этом контракте будет высока, но если все же переживаем - надо заменить на safe арифметику из openzeppelin.
- по расходу газа ничего сказано не было и особо никаких оптимизаций не использовалось, места которые можно было бы соптимизировать озвучены в замечаниям к коду. Но вообще это должно быть частью тз - какие части кода должны быть максимально дешевле, кто за что платит, так как это может оказаться важной частью бизнес-модели.
- Ничего не сказано о взаимодействии DAPP с контрактом, нужны ли какие либо эвенты, например при создании/завершении голосования

## Пояснения по коду

- Структура Voting: Данные об участниках дублируются - при создании голосования мы сохраняем массив адресов участников и одновременно c этим инициализируем mapping присвоив каждому участнику один голос. Это нужно для того что бы быстро определять при учете голоса есть ли у нас вообще такой участник. В тоже время это достаточно дорого и при большом количестве участников может стать проблемой. В ТЗ была рекоменддация использовать как можно быстрые алгоритмы - это попытка такой реализации. Какой имено баланс между скоростью и стоимостью устроит заказчика - нужно выяснять с заказчиком.

- startVoting - тут достаточно линейно все, я решил в качестве id голосования использовать bytes32 - это дает возможность назначать голосованию хэш от его описания и в случае если DAPP опенсорсный - проводить аудит кода и быть уверенным что описание голосования соответсвует его имени. Наибольшее число голосов мы корректируем при каждом голосе, это избавляет нас от одного прохода по всем голосам при завершении голосования (то есть мы сразу знаем max и нам достаточно выбрать всех участников с таким количеством голосов) maxVotes инициализируется сразу в 1 так как число голосов у участников при старте тоже равно 1 (если запишем ноль - не сможем узнавать кто есть в голосовании а кого нет) (в ТЗ оно было названо addVoting, такое название предполагает deleteVoting, а у нас его нет, поэтому я назвал startVoting/finishVoting)

- vote - проверяем согласно ТЗ, учитываем голос, корректируем если необходимо maxVotes

- finishVoting - проверяем что голосование может быть завершено (согласно ТЗ), выбираем победителя(ей), распределяем награду, переносим fee в глобал. При вычислении награды в сценарии с несколькими победителями учитываем что может быть остаток - он идет в пользу owner-а, но этот момент тоже надо проговаривать. Дело в том что остаток не может быть больше чем n-1 где n - число участников, соотв. затраты на вычисления могут быть (и будут в большинстве случаев) выше чем сама сумма остатка. В тоже время платит за это вызывающая метод сторона (один из участников скорее всего) а получает остаток owner. В общем эту логику тоже нужно проговаривать.

- withdraw - тут тоже все линейно, вызвать может только owner, выводятся все средства. если оставлять 1wei - не будет скачков по расходу газа, причем в этот раз расход будет на стороне owner-a (инициализация нулевого значения fee ляжет на первый вызов finishVoting после withdraw, который будет производить admin, который в свою очередь скорее всего нанятый работник owner-а, что значит что скорее всего за это платит owner, так что сценарий с выводом не всех средств может вполне заинтересовать заказчика)

- view функции - сделал необходимый для тестов минимум, там конечно надо еще накидать.

## Тесты

Разбил на несколько групп, каждая группа проверяет определенный этап который в следующей группе может быть вынесен в beforeEach и быть частью контекста. 100% покрытия по бранчам нет так как нет логики отработки отказов. Кроме того поясню - я понимаю что 100% покрытие анализатором говорит только о том что в самих тестах вызывается весь код смарт контракта. О реальном покрытии это не говорит ничего, это зависит от того какие данные состояния мы проверяем и насколько полно отрабатываем все возможные кейсы. навскидку реальное покрытие там порядка 70%. Requre покрыт на 100%, в коде смарткотракта указан тест(ы) которые проверют строку кода.

По тесту f2c (который стоило бы переписать убрав beforeEach так как это все же часть теста в данном случае) - логика нахождения кейса была следующая. мы имеем награду за каждый голос в 9 * 10 в какой то степени, то есть наши множители - 2, 3, 5. Нам нужно голосование в котором число победителей будет взаимно простым с этими множителями (например 7) и при этом число голосов тоже будет взаимно простым с числом победителей. Это дает нам награду которая не делится нацело на число победителей. Голосование с 8 участниками и 7 победителями (2 голоса у каждого и 1 голос у проигравшего) дает нам 15 голосов на 7 победителей, что и покрывает нужную строку кода в finishVoting

## невыполненная часть ТЗ
- деплой - не успел, реально. Опыт деплоя с трафла через инфуру в ринкебай - есть. Я помнится даже тесты прогонял через ринкебай.
- таски и прочая, связанное в hardhat - опять же не успел, но тут могу сразу сказать - если цель понять насколько хорошо знаю hardhat - ни на сколько. За неделю погружусь, неделя что у меня была - по паре часов вечером смотрел, но на этом все. Но по сравнению с трюфелем двухгодовой давности - выглядит все конечно гораздо приятнее.

My first intention was to write all this stuff in English, but again - not enough time and I'm really sorry about it, but at least my English skills we can always verify by just talking, I guess 5 minutes will be quite enough to understand what's what.
